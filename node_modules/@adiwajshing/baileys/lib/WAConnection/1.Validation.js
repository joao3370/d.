"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WAConnection = void 0;
const Curve = __importStar(require("curve25519-js"));
const Utils = __importStar(require("./Utils"));
const _0_Base_1 = require("./0.Base");
const Constants_1 = require("./Constants");
class WAConnection extends _0_Base_1.WAConnection {
    /** Autenticar a conex√£o */
    async authenticate(reconnect) {
        var _a, _b, _c, _d, _e, _f;
        // se nenhuma informa√ß√£o de autentica√ß√£o estiver presente, ou seja, uma nova sess√£o deve ser estabelecida
        // gera um ID de cliente
        if (!((_a = this.authInfo) === null || _a === void 0 ? void 0 : _a.clientID)) {
            this.authInfo = { clientID: Utils.generateClientID() };
        }
        const canLogin = this.canLogin();
        this.referenceDate = new Date(); // atualizar data de refer√™ncia
        this.connectionDebounceTimeout.start();
        const initQuery = (async () => {
            var _a;
            const { ref, ttl } = await this.query({
                json: ['admin', 'init', this.version, this.browserDescription, (_a = this.authInfo) === null || _a === void 0 ? void 0 : _a.clientID, true],
                expect200: true,
                waitForOpen: false,
                longTag: true,
                requiresPhoneConnection: false,
                startDebouncedTimeout: true
            });
            if (!canLogin) {
                this.connectionDebounceTimeout.cancel(); // pare o tempo limite debelado para QR gen
                this.generateKeysForAuth(ref, ttl);
            }
        })();
        let loginTag;
        if (canLogin) {
            // se tivermos informa√ß√µes para restaurar uma sess√£o fechada
            const json = [
                'admin',
                'login',
                (_b = this.authInfo) === null || _b === void 0 ? void 0 : _b.clientToken,
                (_c = this.authInfo) === null || _c === void 0 ? void 0 : _c.serverToken,
                (_d = this.authInfo) === null || _d === void 0 ? void 0 : _d.clientID,
            ];
            loginTag = this.generateMessageTag(true);
            if (reconnect)
                json.push(...['reconectar', reconnect.replace('@s.whatsapp.net', '@c.us')]);
            else
                json.push('takeover'); //nn mexa aqui @Tobi ‚úåüèºüò°
            // send login every 10s
            const sendLoginReq = () => {
                var _a;
                if (!this.conn || ((_a = this.conn) === null || _a === void 0 ? void 0 : _a.readyState) !== this.conn.OPEN) {
                    this.logger.warn('Solicita√ß√£o de tempo limite de login recebido quando o WS n√£o est√° aberto, ignorando ...');
                    return;
                }
                if (this.state === 'open') {
                    this.logger.warn('Solicita√ß√£o de tempo limite de login recebido quando estado = aberto, ignorando ...');
                    return;
                }
                this.logger.debug('enviando pedido de login');
                this.sendJSON(json, loginTag);
                this.initTimeout = setTimeout(sendLoginReq, 10000);
            };
            sendLoginReq();
        }
        await initQuery;
        // aguarde a resposta com a tag "s1"
        let response = await Promise.race([
            this.waitForMessage('s1', false, undefined),
            loginTag && this.waitForMessage(loginTag, false, undefined)
        ]
            .filter(Boolean));
        this.connectionDebounceTimeout.start();
        this.initTimeout && clearTimeout(this.initTimeout);
        this.initTimeout = null;
        if (response.status && response.status !== 200) {
            throw new Constants_1.BaileysError(`Unexpected error in login`, { response, status: response.status });
        }
        // se for um pedido de desafio (o recebemos ao fazer login)
        if ((_e = response[1]) === null || _e === void 0 ? void 0 : _e.challenge) {
            await this.respondToChallenge(response[1].challenge);
            response = await this.waitForMessage('s2', true);
        }
        const result = this.validateNewConnection(response[1]); // valide a conex√£o
        if (result.user.jid !== ((_f = this.user) === null || _f === void 0 ? void 0 : _f.jid)) {
            result.isNewUser = true;
            // limpar dados antigos
            this.chats.clear();
            this.contacts = {};
        }
        this.user = result.user;
        this.logger.info('conex√£o validada com sucesso');
        return result;
    }
    /**
     * Atualizar o c√≥digo QR
     * @retorna o novo ref
     */
    async requestNewQRCodeRef() {
        const response = await this.query({
            json: ['admin', 'Conn', 'reref'],
            expect200: true,
            waitForOpen: false,
            longTag: true,
            requiresPhoneConnection: false
        });
        return response;
    }
    /**
     * Assim que o c√≥digo QR for lido e pudermos validar nossa conex√£o, ou resolvemos o desafio ao fazer o login novamente
     * @privado
     * @param {object} json
     */
    validateNewConnection(json) {
        // definir metadados: ID do WhatsApp [cc] [n√∫mero] @ s.whatsapp.net, nome no WhatsApp, informa√ß√µes sobre o telefone
        const onValidationSuccess = () => ({
            user: {
                jid: Utils.whatsappID(json.wid),
                name: json.pushname,
                phone: json.phone,
                imgUrl: null
            },
            auth: this.authInfo
        });
        if (!json.secret) {
            // se n√£o pegamos um segredo, n√£o precisamos dele, somos validados
            if (json.clientToken && json.clientToken !== this.authInfo.clientToken) {
                this.authInfo = { ...this.authInfo, clientToken: json.clientToken };
            }
            if (json.serverToken && json.serverToken !== this.authInfo.serverToken) {
                this.authInfo = { ...this.authInfo, serverToken: json.serverToken };
            }
            return onValidationSuccess();
        }
        const secret = Buffer.from(json.secret, 'base64');
        if (secret.length !== 144) {
            throw new Error('comprimento de segredo incorreto recebido: ' + secret.length);
        }
        // gerar chave compartilhada de nossa chave privada e o segredo compartilhado pelo servidor
        const sharedKey = Curve.sharedKey(this.curveKeys.private, secret.slice(0, 32));
        // expanda a chave para 80 bytes usando HKDF
        const expandedKey = Utils.hkdf(sharedKey, 80);
        // execute a valida√ß√£o HMAC.
        const hmacValidationKey = expandedKey.slice(32, 64);
        const hmacValidationMessage = Buffer.concat([secret.slice(0, 32), secret.slice(64, secret.length)]);
        const hmac = Utils.hmacSign(hmacValidationMessage, hmacValidationKey);
        if (!hmac.equals(secret.slice(32, 64))) {
            // se as somas de verifica√ß√£o n√£o corresponderem
            throw new Constants_1.BaileysError('A valida√ß√£o do HMAC falhou', json);
        }
        // HMAC calculado deve ser igual a segredo [32:64]
        // ExpandidoKey [64:] + secret [64:] s√£o as chaves, criptografadas usando AES, que s√£o usadas para criptografar / descriptografar as mensagens recebidas do WhatsApp
        // eles s√£o criptografados usando a chave: extendedKey [0:32]
        const encryptedAESKeys = Buffer.concat([
            expandedKey.slice(64, expandedKey.length),
            secret.slice(64, secret.length),
        ]);
        const decryptedKeys = Utils.aesDecrypt(encryptedAESKeys, expandedKey.slice(0, 32));
        // defina as credenciais
        this.authInfo = {
            encKey: decryptedKeys.slice(0, 32),
            macKey: decryptedKeys.slice(32, 64),
            clientToken: json.clientToken,
            serverToken: json.serverToken,
            clientID: this.authInfo.clientID,
        };
        return onValidationSuccess();
    }
    /**
     * Ao fazer o login novamente (restaurando uma sess√£o fechada anteriormente), o WhatsApp pode desafiar algu√©m a verificar se ainda tem as chaves de criptografia
     * O WhatsApp faz isso pedindo que assinemos uma string
     */
    respondToChallenge(challenge) {
        const bytes = Buffer.from(challenge, 'base64'); // decodificar a string de desafio codificada em base64
        const signed = Utils.hmacSign(bytes, this.authInfo.macKey).toString('base64'); // assine a string de desafio com nosso macKey
        const json = ['admin', 'challenge', signed, this.authInfo.serverToken, this.authInfo.clientID]; // prepare-se para enviar esta string assinada com o serverToken & clientID
        this.logger.info('resolvendo o desafio de login');
        return this.query({ json, expect200: true, waitForOpen: false, startDebouncedTimeout: true });
    }
    /** Ao iniciar uma nova sess√£o, gere um c√≥digo QR gerando um par de chaves privadas / p√∫blicas e as chaves que o servidor envia */
    generateKeysForAuth(ref, ttl) {
        this.curveKeys = Curve.generateKeyPair(Utils.randomBytes(32));
        const publicKey = Buffer.from(this.curveKeys.public).toString('base64');
        const qrLoop = ttl => {
            const qr = [ref, publicKey, this.authInfo.clientID].join(',');
            this.emit('qr', qr);
            this.initTimeout = setTimeout(async () => {
                if (this.state === 'open')
                    return;
                this.logger.debug('regenerating QR');
                try {
                    const { ref: newRef, ttl: newTTL } = await this.requestNewQRCodeRef();
                    ttl = newTTL;
                    ref = newRef;
                }
                catch (error) {
                    this.logger.warn({ error }, `error in QR gen`);
                    // @ts-ignore
                    if (error.status === 429 && this.state !== 'open') { // muitos pedidos QR
                        this.endConnection(error.message);
                        return;
                    }
                }
                qrLoop(ttl);
            }, ttl || 20000); // o padr√£o √© 20s, caso o ttl n√£o esteja presente
        };
        qrLoop(ttl);
    }
}
exports.WAConnection = WAConnection;
